<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <priority>0</priority>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>import pya
import math

"""
This sample PCell implements a library called "MyLib" with a single PCell that
draws a circle. It demonstrates the basic implementation techniques for a PCell 
and how to use the "guiding shape" feature to implement a handle for the circle
radius.

NOTE: after changing the code, the macro needs to be rerun to install the new
implementation. The macro is also set to "auto run" to install the PCell 
when KLayout is run.
"""

class CPW(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the circle
  """

  def __init__(self):

    # Important: initialize the super class
    super(CPW, self).__init__()

    # declare the parameters
    #layer 
    self.param("layer", self.TypeLayer, "Layer", default=pya.LayerInfo(13, 0))
    
    #target impedance
    self.param("impedance", self.TypeDouble, "Characteristic Impedance", default=50)
    
    #feed parameters
    self.param("ll", self.TypeDouble, "Length", default=100)
    self.param("wl", self.TypeDouble, "Line Width", default=9.02)
    self.param("wg", self.TypeDouble, "Gap Width", default=14)
   

    #set whether the feeds will be inset or extended off the end of the capacitor or off
    self.param("feedmode", self.TypeString, "FeedMode", default="Off", choices = (["Off","off"],["Inset", "inset"],["Extend","extend"]))
    

  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "CPW(L=" + str(self.ll) + ",Impedance =" + str(self.impedance) + ")"
    
  def produce_impl(self):
    dbu = self.layout.dbu
    # This is the main part of the implementation: create the layout
    length = self.ll
    #does tline need a feed for probe landing (if the line width is too narrow it needs to be bridged)

    wg = self.wg
    wl = self.wl
    #calculate the total gap between the grounds
    gg = 2*wg+wl
    #calculate the groundwidth to 3 times the line + gaps
    gw = 3*gg
    
    #switch case for the feed modes:
    if self.feedmode == "off":
      length = self.ll
    if self.feedmode == "inset":
      ...
    if self.feedmode == "extend":
      ...
    
    
    #create the 3 rectangles that make up part of the tline
    #calculate top ground
    tg = ([0,(gg+gw)/dbu],[length/dbu,(gg+gw*2)/dbu])
    #draw top ground
    self.cell.shapes(self.layer).insert(pya.Box(tg[0][0],tg[0][1],tg[1][0],tg[1][1]))
    
    #calculate tlin
    tl = ([0,(wg+gw)/dbu],[length/dbu,(wg+gw+wl)/dbu])
    #draw tlin
    self.cell.shapes(self.layer).insert(pya.Box(tl[0][0],tl[0][1],tl[1][0],tl[1][1]))
    
    #calculate bottom ground
    bg = ([0,0],[length/dbu,gw/dbu])
    #draw bottom ground
    self.cell.shapes(self.layer).insert(pya.Box(bg[0][0],bg[0][1],bg[1][0],bg[1][1]))


class MIM_Capacitor(pya.PCellDeclarationHelper):
  """
  The PCell declaration for the circle
  """

  def __init__(self):

    # Important: initialize the super class
    super(MIM_Capacitor, self).__init__()

    # declare the parameters
    
    #capacitor layers
    self.param("lb", self.TypeLayer, "BondpadLayer")
    self.param("ld", self.TypeLayer, "DielectricLayer")
    self.param("lp", self.TypeLayer, "BottomPlateLayer")
    
    #capacitor types: series and shunt
    self.param("lp", self.TypeLayer, "BottomPlateLayer")
    
    # Parameter for selecting capacitor mode
    self.param("mode", self.TypeString, "Capacitor Mode", 
                default="series", choices=(["Series", "series"],["Shunt","shunt"]))

    #Parameters for the CPW capacitor
    self.param("lx", self.TypeDouble, "Length X", default=10.0)
    self.param("ly", self.TypeDouble, "Length Y", default=10.0)
    self.param("gap", self.TypeDouble, "Gap", default=6.0)
    self.param("e", self.TypeDouble, "Permittivity", default=7.0)


  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "MIM_CAP(LX=" + str(self.lx) + ",LY=" + str(self.ly) + ")"
  
  def produce_impl(self):
    dbu = self.layout.dbu
    # This is the main part of the implementation: create the layout
    # create the shape
    self.cell.shapes(self.lb).insert(pya.Box(4/dbu,4/dbu,self.lx/dbu,self.ly/dbu))
    self.cell.shapes(self.ld).insert(pya.Box(0,0,(self.lx+4)/dbu,(self.ly+4)/dbu))
    self.cell.shapes(self.lp).insert(pya.Box(2/dbu,2/dbu,(self.lx+2)/dbu,(self.ly+2)/dbu))


class MyLib(pya.Library):
  """
  The library where we will put the PCell into 
  """

  def __init__(self):
  
    # Set the description
    self.description = "GaN_PDK_PASSIVES"
    
    # Create the PCell declarations

    # That would be the place to put in more PCells ...
    self.layout().register_pcell("CPW", CPW())
    self.layout().register_pcell("MIM_Capacitor", MIM_Capacitor())
    
    # Register us with the name "MyLib".
    # If a library with that name already existed, it will be replaced then.
    self.register("GaN_Lib")


# Instantiate and register the library
MyLib()
</text>
</klayout-macro>
